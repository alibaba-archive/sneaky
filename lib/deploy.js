// Generated by CoffeeScript 1.6.3
(function() {
  var Deploy, Moment, async, deploy, exec, execCmd, expandPath, fs, loadConfig, logger, mkdirp, path, sep1, sep2, _, _ref,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  async = require('async');

  path = require('path');

  fs = require('graceful-fs');

  _ = require('underscore');

  Moment = require('moment');

  mkdirp = require('mkdirp');

  logger = require('graceful-logger');

  exec = require('child_process').exec;

  _ref = require('./util'), expandPath = _ref.expandPath, loadConfig = _ref.loadConfig;

  sep1 = '=================================================================';

  sep2 = '-----------------------------------------------------------------';

  execCmd = function(cmd, callback) {
    var child;
    if (callback == null) {
      callback = function() {};
    }
    logger.info("Run command: [" + cmd + "]");
    child = exec(cmd, callback);
    child.stdout.on('data', function(data) {
      return logger.info(data.toString().trim());
    });
    return child.stderr.on('data', function(data) {
      return logger.err(data.toString().trim());
    });
  };

  Deploy = (function() {
    function Deploy(options) {
      this.after = __bind(this.after, this);
      this.before = __bind(this.before, this);
      this.rsync = __bind(this.rsync, this);
      this.archive = __bind(this.archive, this);
      this.autoTag = __bind(this.autoTag, this);
      this.deploy = __bind(this.deploy, this);
      this.getServers = __bind(this.getServers, this);
      var _base;
      this.options = _.extend({
        chdir: "" + process.env.HOME + "/.sneaky",
        force: true,
        config: "" + process.env.HOME + "/.sneakyrc"
      }, options);
      (_base = this.options).config || (_base.config = path.join(path.resolve('./.sneakyrc')));
    }

    Deploy.prototype.getServers = function(project) {
      var i, item, port, server, servers, user, _ref1, _ref2;
      servers = [];
      if (typeof project.servers === 'object') {
        _ref1 = project.servers;
        for (i in _ref1) {
          item = _ref1[i];
          _ref2 = item.split('|'), server = _ref2[0], user = _ref2[1], port = _ref2[2];
          user = user || project.user || this.configs.user || 'root';
          port = port || '22';
          servers.push([server, user, port]);
        }
      } else if (this.configs.servers != null) {
        return this.getServers(this.configs);
      }
      return servers;
    };

    Deploy.prototype.readRecords = function() {
      var e, moment, recordDir;
      moment = new Moment;
      recordDir = path.join(this.options.chdir, "_records");
      try {
        this.records = require(path.join(recordDir, "" + (moment.format('YYYYMMDD')) + ".json"));
      } catch (_error) {
        e = _error;
        this.records = {};
      }
      return this.records;
    };

    Deploy.prototype.writeRecords = function(callback) {
      var recordDir,
        _this = this;
      if (callback == null) {
        callback = function() {};
      }
      recordDir = path.join(this.options.chdir, "_records");
      return mkdirp(recordDir, function(err, parent) {
        var moment;
        if (err != null) {
          logger.err("Cound not mkdir " + recordDir, 1);
        }
        moment = new Moment;
        return fs.writeFile(path.join(recordDir, "" + (moment.format('YYYYMMDD')) + ".json"), JSON.stringify(_this.records, null, 2), function(err, result) {
          if (err != null) {
            logger.err("Cound not write record file", 1);
          }
          return callback(err, result);
        });
      });
    };

    Deploy.prototype.run = function(callback) {
      var _this = this;
      if (callback == null) {
        callback = function() {};
      }
      return loadConfig(this.options.config, function(err, configs) {
        var allProjects, k, records, runProjects, start, v, _ref1;
        if (configs == null) {
          return callback("Missing config file");
        }
        if (_.isEmpty(configs.projects)) {
          logger.err('please define the project info in the `projects` collection', 1);
        }
        _this.configs = configs;
        start = new Date();
        logger.info(sep1);
        logger.info('Job start at', start);
        records = _this.readRecords();
        runProjects = [];
        allProjects = configs.projects;
        if (((_ref1 = _this.options.projects) != null ? _ref1.length : void 0) > 0) {
          _this.options.projects.forEach(function(projectName) {
            if (allProjects[projectName] != null) {
              return runProjects.push(allProjects[projectName]);
            } else {
              return logger.warn("Can not find project [" + projectName + "]");
            }
          });
        } else {
          runProjects = (function() {
            var _ref2, _results;
            _ref2 = configs.projects;
            _results = [];
            for (k in _ref2) {
              v = _ref2[k];
              _results.push(v);
            }
            return _results;
          })();
        }
        return async.eachSeries(runProjects, _this.deploy, function(err, result) {
          var end;
          if (err != null) {
            logger.err(err.toString());
            logger.err('Deploy Failed!', 1);
          } else {
            end = new Date();
            logger.info('Time cost:', (end - start) / 1000, " Seconds");
            logger.info('Deploy finished at', end);
            logger.info('Please checkout your remote directory');
          }
          logger.info(sep1);
          return callback(err, result);
        });
      });
    };

    Deploy.prototype.deploy = function(project, callback) {
      var _ref1,
        _this = this;
      if (callback == null) {
        callback = function() {};
      }
      if (project.name === 'template') {
        return callback(null);
      }
      logger.info(sep2);
      logger.info("Start deploy [" + project.name + "]");
      if (((_ref1 = this.records[project.name]) === 'success' || _ref1 === 'processing') && !this.options.force) {
        logger.warn("Project [" + project.name + "] has been deployed, skipping...");
        logger.info(sep2);
        return callback(null);
      }
      this.records[project.name] = 'processing';
      this.writeRecords();
      return async.waterfall([
        (function(next) {
          return _this.autoTag(project, next);
        }), this.archive, this.before, this.rsync, this.after
      ], function(err, result) {
        if (err != null) {
          logger.err(err);
          _this.records[project.name] = 'fail';
        } else {
          _this.records[project.name] = 'success';
          logger.info("Finish deploy [" + project.name + "]");
        }
        _this.writeRecords();
        logger.info(sep2);
        return callback(err, project);
      });
    };

    Deploy.prototype.autoTag = function(project, callback) {
      var _this = this;
      if (callback == null) {
        callback = function() {};
      }
      if (!project.autoTag) {
        return callback(null, project);
      }
      if (!project.source.match(/^[a-zA-Z._\/\~\-]+$/)) {
        return callback(("" + project.source + " is not a local repository, ") + "you could not use `autoTag` for a remote repository.");
      }
      process.chdir(expandPath(project.source));
      return execCmd('git tag', function(err, data) {
        var moment, newTag, tagCmd;
        if (err != null) {
          return callback(err);
        }
        moment = new Moment();
        newTag = "" + (project.tagPrefix || 'release') + "-" + (moment.format('YYYY.MM.DD.HHmmss'));
        tagCmd = ("git tag " + newTag + " -m 'auto generated tag " + newTag + " by sneaky ") + ("at " + (moment.format('YYYY-MM-DD HH:mm:ss')) + "'");
        return execCmd(tagCmd, function(err, data) {
          project.version = newTag;
          return callback(err, project);
        });
      });
    };

    Deploy.prototype.archive = function(project, callback) {
      var gitCmd, prefix,
        _this = this;
      if (callback == null) {
        callback = function() {};
      }
      prefix = project.prefix || project.name + '/';
      if (project.source == null) {
        return callback('missing project source directory');
      }
      gitCmd = ("rm -rf " + (path.join(this.options.chdir, prefix)) + "; ") + ("git archive " + (project.version || 'HEAD') + " --prefix=" + prefix + " ") + ("--remote=" + project.source + " --format=tar | tar -xf - -C " + this.options.chdir);
      return execCmd(gitCmd, function(err, data) {
        return callback(err, project);
      });
    };

    Deploy.prototype.rsync = function(project, callback) {
      if (callback == null) {
        callback = function() {};
      }
      if (project.local) {
        return this._localRsync(project, callback);
      } else {
        return this._sshRsync(project, callback);
      }
    };

    Deploy.prototype._sshRsync = function(project, callback) {
      var excludes, servers,
        _this = this;
      if (callback == null) {
        callback = function() {};
      }
      servers = this.getServers(project);
      excludes = [];
      if (typeof project.excludes === 'object' && project.excludes.length > 0) {
        excludes = project.excludes.map(function(item) {
          return "--exclude=" + item;
        });
      }
      return async.eachSeries(servers, (function(server, next) {
        var rsyncCmd;
        rsyncCmd = project.rsyncCmd || "rsync -a --timeout=15 --delete-after --ignore-errors --force" + (" -e \"ssh -p " + server[2] + "\" ") + excludes.join(' ') + (" " + _this.options.chdir + "/" + project.name + "/ " + server[1] + "@" + server[0] + ":" + project.destination);
        return execCmd(rsyncCmd, function(err, data) {
          return next(err);
        });
      }), function(err, result) {
        return callback(err, project);
      });
    };

    Deploy.prototype._localRsync = function(project, callback) {
      var excludes, rsyncCmd;
      if (callback == null) {
        callback = function() {};
      }
      if (typeof project.excludes === 'object' && project.excludes.length > 0) {
        excludes = project.excludes.map(function(item) {
          return "--exclude=" + item;
        });
        rsyncCmd = project.rsyncCmd || "rsync -a --timeout=15 --delete-after --ignore-errors --force" + " " + excludes.join(' ') + (" " + this.options.chdir + "/" + project.name + "/ " + project.destination);
        return execCmd(rsyncCmd, function(err, data) {
          return callback(err, project);
        });
      }
    };

    Deploy.prototype.before = function(project, callback) {
      var prefix;
      if (callback == null) {
        callback = function() {};
      }
      if ((project.before != null) && typeof project.before === 'string') {
        logger.info('Before hook:', project.before);
        prefix = project.prefix || project.name + '/';
        process.chdir("" + this.options.chdir + "/" + prefix);
        return execCmd(project.before, function(err, data) {
          return callback(err, project);
        });
      } else {
        return callback(null, project);
      }
    };

    Deploy.prototype.after = function(project, callback) {
      var prefix, servers;
      if (callback == null) {
        callback = function() {};
      }
      servers = this.getServers(project);
      prefix = project.prefix || project.name + '/';
      if ((project.after != null) && typeof project.after === 'string') {
        logger.info('After hook:');
        if (project.local) {
          logger.info(project.after);
          return execCmd(project.after, function(err, data) {
            return callback(err, project);
          });
        } else {
          return async.eachSeries(servers, (function(server, next) {
            var sshCmd;
            sshCmd = "ssh -t -t " + server[1] + "@" + server[0] + " -p " + server[2] + " \"" + project.after + "\"";
            logger.info(sshCmd);
            return execCmd(sshCmd, function(err, data) {
              return next(err);
            });
          }), function(err, result) {
            return callback(err, project);
          });
        }
      } else {
        return callback(null, project);
      }
    };

    return Deploy;

  })();

  deploy = function(options) {
    var $deploy;
    $deploy = new Deploy(options);
    return $deploy.run();
  };

  deploy.Deploy = Deploy;

  module.exports = deploy;

}).call(this);
