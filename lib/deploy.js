// Generated by CoffeeScript 1.6.3
(function() {
  var Deploy, Moment, async, deploy, exec, execCmd, expandPath, fs, jsYaml, logger, mkdirp, path, sep1, sep2, spawn, spawnCmd, _,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  async = require('async');

  path = require('path');

  fs = require('graceful-fs');

  jsYaml = require('js-yaml');

  _ = require('underscore');

  logger = require('graceful-logger');

  exec = require('child_process').exec;

  spawn = require('child_process').spawn;

  Moment = require('moment');

  mkdirp = require('mkdirp');

  sep1 = '=================================================================';

  sep2 = '-----------------------------------------------------------------';

  expandPath = function(srcPath) {
    var matches;
    if (matches = srcPath.match(/^~(.*)/)) {
      return "" + process.env.HOME + matches[1];
    } else {
      return srcPath;
    }
  };

  execCmd = function(cmd, callback) {
    if (callback == null) {
      callback = function() {};
    }
    logger.info("Run command: [" + cmd + "]");
    return exec(cmd, function(err, data) {
      logger.info(data.toString());
      return callback(err, data);
    });
  };

  spawnCmd = function(cmd, options, callback) {
    var isQuiet, job, stderr, stdout;
    if (callback == null) {
      callback = function() {};
    }
    if (arguments.length < 3) {
      callback = options || function() {};
    }
    isQuiet = options.quiet || false;
    stdout = '';
    stderr = '';
    job = spawn('bash', ['-c', cmd]);
    job.stdout.setEncoding('utf-8');
    job.stdout.on('data', function(data) {
      data = data.trim();
      stdout += data;
      return logger.info(data);
    });
    job.stderr.setEncoding('utf-8');
    job.stderr.on('data', function(data) {
      data = data.trim();
      stderr += data;
      return logger.warn(data);
    });
    return job.on('close', function(code) {
      if (code !== 0) {
        return callback(stderr);
      }
      return callback(code, stdout);
    });
  };

  Deploy = (function() {
    function Deploy(options) {
      this.after = __bind(this.after, this);
      this.before = __bind(this.before, this);
      this.rsync = __bind(this.rsync, this);
      this.archive = __bind(this.archive, this);
      this.autoTag = __bind(this.autoTag, this);
      this.deploy = __bind(this.deploy, this);
      this.getServers = __bind(this.getServers, this);
      this.options = _.extend({
        chdir: "" + process.env.HOME + "/.sneaky",
        force: false
      }, options);
    }

    Deploy.prototype.loadConfigs = function() {
      var configFile, err;
      configFile = expandPath(this.options.config || '~/.sneakyrc');
      try {
        this.configs = jsYaml.load(fs.readFileSync(configFile, 'utf-8'));
      } catch (_error) {
        err = _error;
        switch (err != null ? err.name : void 0) {
          case 'YAMLException':
            logger.err("please check your configure file's format");
            break;
          default:
            logger.err("missing sneakyrc file, did you put this file in path " + configFile + " ?");
        }
      }
      if (!((this.configs.projects != null) && this.configs.projects.length > 0)) {
        logger.err('please define the project info in the `projects` collection');
      }
      return this.configs;
    };

    Deploy.prototype.getServers = function(project) {
      var i, item, port, server, servers, user, _ref, _ref1, _ref2;
      servers = [];
      if (typeof project.servers === 'string') {
        _ref = project.servers.split('|'), server = _ref[0], user = _ref[1], port = _ref[2];
        user = user || local.configs.user || 'root';
        port = port || '22';
        servers.push([server, user, port]);
      } else if (typeof project.servers === 'object') {
        _ref1 = project.servers;
        for (i in _ref1) {
          item = _ref1[i];
          _ref2 = item.split('|'), server = _ref2[0], user = _ref2[1], port = _ref2[2];
          user = user || local.configs.user || 'root';
          port = port || '22';
          servers.push([server, user, port]);
        }
      } else if (this.configs.servers != null) {
        return this.getServers(this.configs);
      }
      return servers;
    };

    Deploy.prototype.readActionRecord = function() {
      var actionRecord, e, moment;
      moment = new Moment;
      try {
        actionRecord = fs.readFileSync(path.join(this.options.chdir, "var/actions/" + (moment.format('YYYY-MM-DD')) + ".txt"));
        return this.records = JSON.parse(actionRecord);
      } catch (_error) {
        e = _error;
        return this.records = {};
      }
    };

    Deploy.prototype.writeActionRecord = function(callback) {
      var actionDir,
        _this = this;
      if (callback == null) {
        callback = function() {};
      }
      actionDir = path.join(this.options.chdir, "var/actions");
      return mkdirp(actionDir, function(err, parent) {
        var moment;
        if (err != null) {
          logger.err("Cound not mkdir " + actionDir);
          return callback(err, parent);
        } else {
          moment = new Moment;
          return fs.writeFile(path.join(actionDir, "" + (moment.format('YYYY-MM-DD')) + ".txt"), JSON.stringify(_this.records, null, 2), function(err, result) {
            if (err != null) {
              logger.err("Cound not write record file");
            }
            return callback(err, result);
          });
        }
      });
    };

    Deploy.prototype.run = function(callback) {
      var allProjects, configs, i, project, projectNames, projects, records, start, _ref;
      if (callback == null) {
        callback = function() {};
      }
      configs = this.loadConfigs();
      if (configs == null) {
        return callback("Missing config file");
      }
      start = new Date();
      logger.info(sep1);
      logger.info('Job start at', start);
      records = this.readActionRecord();
      projects = [];
      allProjects = {};
      _ref = this.configs.projects;
      for (i in _ref) {
        project = _ref[i];
        allProjects[project.name] = project;
      }
      if (this.options.projects != null) {
        projectNames = this.options.projects.split(',');
        projectNames.forEach(function(projectName) {
          if (allProjects[projectName] != null) {
            return projects.push(allProjects[projectName]);
          } else {
            return logger.warn("Can not find project [" + projectName + "]");
          }
        });
      } else {
        projects = this.configs.projects;
      }
      return async.eachSeries(projects, this.deploy, function(err, result) {
        var end;
        if (err != null) {
          logger.err(err.toString());
          logger.err('Deploy Failed!');
        } else {
          end = new Date();
          logger.info('Time cost:', (end - start) / 1000, " Seconds");
          logger.info('Deploy finished at', end);
          logger.info('Please checkout your remote directory');
        }
        logger.info(sep1);
        return callback(err, result);
      });
    };

    Deploy.prototype.deploy = function(project, callback) {
      var _ref,
        _this = this;
      if (callback == null) {
        callback = function() {};
      }
      logger.info(sep2);
      logger.info("Start deploy [" + project.name + "]");
      if (((_ref = this.records[project.name]) === 'success' || _ref === 'processing') && !this.options.force) {
        logger.warn("Project [" + project.name + "] has been deployed, skipping...");
        logger.info(sep2);
        return callback(null);
      }
      this.records[project.name] = 'processing';
      this.writeActionRecord();
      return async.waterfall([
        (function(next) {
          return _this.autoTag(project, next);
        }), this.archive, this.before, this.rsync, this.after
      ], function(err, result) {
        if (err != null) {
          logger.err(err);
          _this.records[project.name] = 'fail';
        } else {
          _this.records[project.name] = 'success';
          logger.info("Finish deploy [" + project.name + "]");
        }
        _this.writeActionRecord();
        logger.info(sep2);
        return callback(err, project);
      });
    };

    Deploy.prototype.autoTag = function(project, callback) {
      var _this = this;
      if (callback == null) {
        callback = function() {};
      }
      if (!project.autoTag) {
        return callback(null, project);
      }
      if (!project.source.match(/^[a-zA-Z._\/\~\-]+$/)) {
        return callback(("" + project.source + " is not a local repos, ") + "you could not use `autoTag` for a remote repos.");
      }
      process.chdir(expandPath(project.source));
      return execCmd('git tag', function(err, data) {
        var moment, newTag, tagCmd;
        if (err != null) {
          return callback(err);
        }
        moment = new Moment();
        newTag = "" + (project.tagPrefix || 'release') + "-" + (moment.format('YYYY.MM.DD.HHmmss'));
        tagCmd = "git tag " + newTag + " -m 'auto generated tag " + newTag + " by sneaky at " + (moment.format('YYYY-MM-DD HH:mm:ss')) + "'";
        return execCmd(tagCmd, function(err, data) {
          project.version = newTag;
          return callback(err, project);
        });
      });
    };

    Deploy.prototype.archive = function(project, callback) {
      var gitCmd, prefix,
        _this = this;
      if (callback == null) {
        callback = function() {};
      }
      prefix = project.prefix || project.name + '/';
      gitCmd = ("rm -rf " + (path.join(this.options.chdir, prefix)) + "; git archive " + (project.version || 'HEAD') + " --prefix=" + prefix + " ") + ("--remote=" + project.source + " --format=tar | tar -xf - -C " + this.options.chdir);
      return execCmd(gitCmd, function(err, data) {
        process.chdir("" + _this.options.chdir + "/" + prefix);
        return callback(err, project);
      });
    };

    Deploy.prototype.rsync = function(project, callback) {
      var excludes, servers,
        _this = this;
      if (callback == null) {
        callback = function() {};
      }
      servers = this.getServers(project);
      excludes = [];
      if (typeof project.excludes === 'object' && project.excludes.length > 0) {
        excludes = project.excludes.map(function(item) {
          return "--exclude=" + item;
        });
      }
      return async.eachSeries(servers, (function(server, next) {
        var rsyncCmd;
        rsyncCmd = project.rsyncCmd || "rsync -a --timeout=15 --delete-after --ignore-errors --force" + (" -e \"ssh -p " + server[2] + "\" ") + excludes.join(' ') + (" " + _this.options.chdir + "/" + project.name + "/ " + server[1] + "@" + server[0] + ":" + project.destination);
        return execCmd(rsyncCmd, function(err, data) {
          return next(err);
        });
      }), function(err, result) {
        return callback(err, project);
      });
    };

    Deploy.prototype.before = function(project, callback) {
      if (callback == null) {
        callback = function() {};
      }
      if ((project.before != null) && typeof project.before === 'string') {
        logger.info('Before hook:', project.before);
        return spawnCmd(project.before, function(err, data) {
          return callback(err, project);
        });
      } else {
        return callback(null, project);
      }
    };

    Deploy.prototype.after = function(project, callback) {
      var prefix, servers;
      if (callback == null) {
        callback = function() {};
      }
      servers = this.getServers(project);
      prefix = project.prefix || project.name + '/';
      if ((project.after != null) && typeof project.after === 'string') {
        logger.info('After hook:');
        return async.eachSeries(servers, (function(server, next) {
          var sshCmd;
          sshCmd = "ssh -t -t " + server[1] + "@" + server[0] + " -p " + server[2] + " \"" + project.after + "\"";
          logger.info(sshCmd);
          return spawnCmd(sshCmd, function(err, data) {
            return next(err);
          });
        }), function(err, result) {
          return callback(err, project);
        });
      } else {
        return callback(null, project);
      }
    };

    return Deploy;

  })();

  deploy = function(options) {
    var $deploy;
    $deploy = new Deploy(options);
    return $deploy.run();
  };

  deploy.Deploy = Deploy;

  module.exports = deploy;

}).call(this);
