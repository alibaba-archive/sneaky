// Generated by CoffeeScript 1.6.3
(function() {
  var Deploy, Moment, async, deploy, exec, execCmd, expandPath, expandToArray, fs, ini, logger, mkdirp, path, sep1, sep2, spawn, spawnCmd, _, _ref,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  async = require('async');

  path = require('path');

  fs = require('graceful-fs');

  _ = require('underscore');

  ini = require('ini');

  logger = require('graceful-logger');

  _ref = require('child_process'), exec = _ref.exec, spawn = _ref.spawn;

  Moment = require('moment');

  mkdirp = require('mkdirp');

  sep1 = '=================================================================';

  sep2 = '-----------------------------------------------------------------';

  expandPath = function(srcPath) {
    var matches;
    if (matches = srcPath.match(/^~(.*)/)) {
      return "" + process.env.HOME + matches[1];
    } else {
      return srcPath;
    }
  };

  execCmd = function(cmd, callback) {
    if (callback == null) {
      callback = function() {};
    }
    logger.info("Run command: [" + cmd + "]");
    return exec(cmd, function(err, data) {
      logger.info(data.toString());
      return callback(err, data);
    });
  };

  spawnCmd = function(cmd, options, callback) {
    var isQuiet, job, stderr, stdout;
    if (callback == null) {
      callback = function() {};
    }
    if (arguments.length < 3) {
      callback = options || function() {};
    }
    isQuiet = options.quiet || false;
    stdout = '';
    stderr = '';
    job = spawn('bash', ['-c', cmd]);
    job.stdout.setEncoding('utf-8');
    job.stdout.on('data', function(data) {
      data = data.trim();
      stdout += data;
      return logger.info(data);
    });
    job.stderr.setEncoding('utf-8');
    job.stderr.on('data', function(data) {
      data = data.trim();
      stderr += data;
      return logger.warn(data);
    });
    return job.on('close', function(code) {
      if (code !== 0) {
        return callback(stderr);
      }
      return callback(code, stdout);
    });
  };

  expandToArray = function(str) {
    if (typeof str === 'string' && str.length > 0) {
      return str.split(',').map(function(r) {
        return r.trim();
      });
    }
    return [];
  };

  Deploy = (function() {
    function Deploy(options) {
      this.after = __bind(this.after, this);
      this.before = __bind(this.before, this);
      this.rsync = __bind(this.rsync, this);
      this.archive = __bind(this.archive, this);
      this.autoTag = __bind(this.autoTag, this);
      this.deploy = __bind(this.deploy, this);
      this.getServers = __bind(this.getServers, this);
      this.options = _.extend({
        chdir: "" + process.env.HOME + "/.sneaky",
        force: false,
        config: "" + process.env.HOME + "/.sneakyrc"
      }, options);
    }

    Deploy.prototype.loadConfigs = function(callback) {
      var configFile,
        _this = this;
      if (callback == null) {
        callback = function() {};
      }
      configFile = expandPath(this.options.config || '~/.sneakyrc');
      return fs.readFile(configFile, function(err, content) {
        var configs, k, kk, projectPrefix, v, vv, _configs, _project;
        if (err != null) {
          return callback(err, content);
        }
        configs = ini.parse(content.toString());
        _configs = {};
        projectPrefix = 'project:';
        for (k in configs) {
          v = configs[k];
          if (k.indexOf(projectPrefix) === 0) {
            if (_configs.projects == null) {
              _configs.projects = {};
            }
            _project = v;
            for (kk in _project) {
              vv = _project[kk];
              switch (kk) {
                case 'excludes':
                case 'servers':
                  _project[kk] = expandToArray(vv);
              }
            }
            _project.name = k.slice(projectPrefix.length).trim();
            _configs['projects'][_project.name] = _project;
            continue;
          }
          _configs[k] = v;
        }
        if (_.isEmpty(_configs.projects)) {
          logger.err('please define the project info in the `projects` collection', 1);
        }
        _this.configs = _configs;
        return callback(err, _configs);
      });
    };

    Deploy.prototype.getServers = function(project) {
      var i, item, port, server, servers, user, _ref1, _ref2;
      servers = [];
      if (typeof project.servers === 'object') {
        _ref1 = project.servers;
        for (i in _ref1) {
          item = _ref1[i];
          _ref2 = item.split('|'), server = _ref2[0], user = _ref2[1], port = _ref2[2];
          user = user || project.user || this.configs.user || 'root';
          port = port || '22';
          servers.push([server, user, port]);
        }
      } else if (this.configs.servers != null) {
        return this.getServers(this.configs);
      }
      return servers;
    };

    Deploy.prototype.readRecords = function() {
      var e, moment, recordDir;
      moment = new Moment;
      recordDir = path.join(this.options.chdir, "_records");
      try {
        this.records = require(path.join(recordDir, "" + (moment.format('YYYYMMDD')) + ".json"));
      } catch (_error) {
        e = _error;
        this.records = {};
      }
      return this.records;
    };

    Deploy.prototype.writeRecords = function(callback) {
      var recordDir,
        _this = this;
      if (callback == null) {
        callback = function() {};
      }
      recordDir = path.join(this.options.chdir, "_records");
      return mkdirp(recordDir, function(err, parent) {
        var moment;
        if (err != null) {
          logger.err("Cound not mkdir " + recordDir, 1);
        }
        moment = new Moment;
        return fs.writeFile(path.join(recordDir, "" + (moment.format('YYYYMMDD')) + ".json"), JSON.stringify(_this.records, null, 2), function(err, result) {
          if (err != null) {
            logger.err("Cound not write record file", 1);
          }
          return callback(err, result);
        });
      });
    };

    Deploy.prototype.run = function(callback) {
      var _this = this;
      if (callback == null) {
        callback = function() {};
      }
      return this.loadConfigs(function(err, configs) {
        var allProjects, k, records, runProjects, start, v, _ref1;
        if (configs == null) {
          return callback("Missing config file");
        }
        start = new Date();
        logger.info(sep1);
        logger.info('Job start at', start);
        records = _this.readRecords();
        runProjects = [];
        allProjects = configs.projects;
        if (((_ref1 = _this.options.projects) != null ? _ref1.length : void 0) > 0) {
          _this.options.projects.forEach(function(projectName) {
            if (allProjects[projectName] != null) {
              return runProjects.push(allProjects[projectName]);
            } else {
              return logger.warn("Can not find project [" + projectName + "]");
            }
          });
        } else {
          runProjects = (function() {
            var _ref2, _results;
            _ref2 = configs.projects;
            _results = [];
            for (k in _ref2) {
              v = _ref2[k];
              _results.push(v);
            }
            return _results;
          })();
        }
        return async.eachSeries(runProjects, _this.deploy, function(err, result) {
          var end;
          if (err != null) {
            logger.err(err.toString());
            logger.err('Deploy Failed!', 1);
          } else {
            end = new Date();
            logger.info('Time cost:', (end - start) / 1000, " Seconds");
            logger.info('Deploy finished at', end);
            logger.info('Please checkout your remote directory');
          }
          logger.info(sep1);
          return callback(err, result);
        });
      });
    };

    Deploy.prototype.deploy = function(project, callback) {
      var _ref1,
        _this = this;
      if (callback == null) {
        callback = function() {};
      }
      logger.info(sep2);
      logger.info("Start deploy [" + project.name + "]");
      if (((_ref1 = this.records[project.name]) === 'success' || _ref1 === 'processing') && !this.options.force) {
        logger.warn("Project [" + project.name + "] has been deployed, skipping...");
        logger.info(sep2);
        return callback(null);
      }
      this.records[project.name] = 'processing';
      this.writeRecords();
      return async.waterfall([
        (function(next) {
          return _this.autoTag(project, next);
        }), this.archive, this.before, this.rsync, this.after
      ], function(err, result) {
        if (err != null) {
          logger.err(err);
          _this.records[project.name] = 'fail';
        } else {
          _this.records[project.name] = 'success';
          logger.info("Finish deploy [" + project.name + "]");
        }
        _this.writeRecords();
        logger.info(sep2);
        return callback(err, project);
      });
    };

    Deploy.prototype.autoTag = function(project, callback) {
      var _this = this;
      if (callback == null) {
        callback = function() {};
      }
      if (!project.autoTag) {
        return callback(null, project);
      }
      if (!project.source.match(/^[a-zA-Z._\/\~\-]+$/)) {
        return callback(("" + project.source + " is not a local repository, ") + "you could not use `autoTag` for a remote repository.");
      }
      process.chdir(expandPath(project.source));
      return execCmd('git tag', function(err, data) {
        var moment, newTag, tagCmd;
        if (err != null) {
          return callback(err);
        }
        moment = new Moment();
        newTag = "" + (project.tagPrefix || 'release') + "-" + (moment.format('YYYY.MM.DD.HHmmss'));
        tagCmd = "git tag " + newTag + " -m 'auto generated tag " + newTag + " by sneaky at " + (moment.format('YYYY-MM-DD HH:mm:ss')) + "'";
        return execCmd(tagCmd, function(err, data) {
          project.version = newTag;
          return callback(err, project);
        });
      });
    };

    Deploy.prototype.archive = function(project, callback) {
      var gitCmd, prefix,
        _this = this;
      if (callback == null) {
        callback = function() {};
      }
      prefix = project.prefix || project.name + '/';
      gitCmd = ("rm -rf " + (path.join(this.options.chdir, prefix)) + "; git archive " + (project.version || 'HEAD') + " --prefix=" + prefix + " ") + ("--remote=" + project.source + " --format=tar | tar -xf - -C " + this.options.chdir);
      return execCmd(gitCmd, function(err, data) {
        return callback(err, project);
      });
    };

    Deploy.prototype.rsync = function(project, callback) {
      if (callback == null) {
        callback = function() {};
      }
      if (project.local) {
        return this._localRsync(project, callback);
      } else {
        return this._sshRsync(project, callback);
      }
    };

    Deploy.prototype._sshRsync = function(project, callback) {
      var excludes, servers,
        _this = this;
      if (callback == null) {
        callback = function() {};
      }
      servers = this.getServers(project);
      excludes = [];
      if (typeof project.excludes === 'object' && project.excludes.length > 0) {
        excludes = project.excludes.map(function(item) {
          return "--exclude=" + item;
        });
      }
      return async.eachSeries(servers, (function(server, next) {
        var rsyncCmd;
        rsyncCmd = project.rsyncCmd || "rsync -a --timeout=15 --delete-after --ignore-errors --force" + (" -e \"ssh -p " + server[2] + "\" ") + excludes.join(' ') + (" " + _this.options.chdir + "/" + project.name + "/ " + server[1] + "@" + server[0] + ":" + project.destination);
        return execCmd(rsyncCmd, function(err, data) {
          return next(err);
        });
      }), function(err, result) {
        return callback(err, project);
      });
    };

    Deploy.prototype._localRsync = function(project, callback) {
      var excludes, rsyncCmd;
      if (callback == null) {
        callback = function() {};
      }
      if (typeof project.excludes === 'object' && project.excludes.length > 0) {
        excludes = project.excludes.map(function(item) {
          return "--exclude=" + item;
        });
        rsyncCmd = project.rsyncCmd || "rsync -a --timeout=15 --delete-after --ignore-errors --force" + " " + excludes.join(' ') + (" " + this.options.chdir + "/" + project.name + "/ " + project.destination);
        return execCmd(rsyncCmd, function(err, data) {
          return callback(err, project);
        });
      }
    };

    Deploy.prototype.before = function(project, callback) {
      var prefix;
      if (callback == null) {
        callback = function() {};
      }
      if ((project.before != null) && typeof project.before === 'string') {
        logger.info('Before hook:', project.before);
        prefix = project.prefix || project.name + '/';
        process.chdir("" + this.options.chdir + "/" + prefix);
        return spawnCmd(project.before, function(err, data) {
          return callback(err, project);
        });
      } else {
        return callback(null, project);
      }
    };

    Deploy.prototype.after = function(project, callback) {
      var prefix, servers;
      if (callback == null) {
        callback = function() {};
      }
      servers = this.getServers(project);
      prefix = project.prefix || project.name + '/';
      if ((project.after != null) && typeof project.after === 'string') {
        logger.info('After hook:');
        return async.eachSeries(servers, (function(server, next) {
          var sshCmd;
          sshCmd = "ssh -t -t " + server[1] + "@" + server[0] + " -p " + server[2] + " \"" + project.after + "\"";
          logger.info(sshCmd);
          return spawnCmd(sshCmd, function(err, data) {
            return next(err);
          });
        }), function(err, result) {
          return callback(err, project);
        });
      } else {
        return callback(null, project);
      }
    };

    return Deploy;

  })();

  deploy = function(options) {
    var $deploy;
    $deploy = new Deploy(options);
    return $deploy.run();
  };

  deploy.Deploy = Deploy;

  module.exports = deploy;

}).call(this);
